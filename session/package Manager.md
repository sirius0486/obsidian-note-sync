## node_modules

### 依赖嵌套🪆
npm2 的 node_modules 是嵌套的， 多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，这直接导致磁盘空间的急速膨胀, 直观的感受就是`npm install`的时候需要等待非常长的时间，或者超时，同时吃掉你一部分的磁盘空间（甚至以GB为单位😭） 

除此之外导致的一个最致命问题是 `windows` 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。

### 嵌套拍平（扁平化）和 locke 锁文件
当时npm并没有解决这个问题，所以yarn就诞生出来并解决这个问题，并且npm在随后的版本中也跟进了这个feture. (btw, lock锁文件可以锁定依赖版本也是yarn最先实现的，npm也在随后跟进了)


### 幽灵依赖👻
但是这个方案并没有完全解决问题，扁平化的方案也有相应的问题。

最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。

这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。

但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。

这就是幽灵依赖的问题。

而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。

### pnpm
pnpm 是一个 Node.js 包管理器，它可以用来代替 npm 或 Yarn。pnpm 支持 Monorepo，可以通过 `pnpm-workspace.yaml` 文件在多个子项目之间共享依赖项。pnpm 的 monorepo 特性和 Yarn Workspaces、Lerna 类似，都是为了解决多个相关项目共享代码和依赖项的问题。

pnpm 通过共享依赖来减少磁盘空间的使用，并且通过并行安装依赖项来提高安装速度。

。它由 npm/yarn 衍生而来，但却解决了 npm/yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景。

以下是 pnpm 的一些优缺点：

优点：

-   磁盘空间使用更少：pnpm 通过共享依赖项来减少磁盘空间的使用。如果多个项目都使用了同一个依赖项，那么这个依赖项只会被下载一次，并且被共享到这些项目中。
-   更快的安装速度：pnpm 支持并行安装依赖项，这样可以更快地完成安装。pnpm 还可以缓存已经安装的依赖项，这样可以避免重复下载。
-   更好的 monorepo 支持：pnpm 支持 monorepo 环境，并且可以通过共享依赖项来减少重复的安装。这样可以使 monorepo 环境更加高效。

1.  **安装速度最快**（非扁平的包结构，没有`yarn/npm`的复杂的扁平算法，且只更新变化的文件）
2.  **节省磁盘空间** （统一安装包到磁盘的某个位置，项目中的`node_modules`通过`hard-link`的方式链接到实际的安装地址）

缺点：

-   相对较新：pnpm 是一个比较新的包管理器，相对于 npm 和 Yarn 来说还没有那么成熟和稳定。可能存在某些不兼容或者 bug。
-   可能需要一些配置：pnpm 在使用过程中可能需要一些额外的配置，以便更好地支持 monorepo 环境或者与其他工具协同使用。



### Monorepo
如果你打算把前后端都放在同一个 repo 里面，可以考虑使用 monorepo 工具来
进行依赖管理和复用。

monorepo 是指将多个相关的项目（如前端、后端、测试等）放在一个仓库中进行管理，通过共享依赖来提高开发效率和代码可维护性。在 monorepo 中，可以将共享的代码或库放在一个单独的目录中，并在各个子项目中引用它们，避免了重复的代码和依赖管理。

一些常用的 monorepo 工具包括：

-   Lerna：一个 JavaScript 工具，用于管理具有多个软件包的 JavaScript 项目的工作流程。
-   Yarn Workspaces：Yarn 自带的 monorepo 工具，可以将多个项目共享依赖和配置。
-   Nx：一个集成了 Lerna 和 Yarn Workspaces 的 monorepo 工具，用于构建和测试 Angular、React 和 Node.js 应用。

使用 monorepo 可以简化项目的管理和维护，并且提高代码复用性。


当一个项目包含多个独立但相关的组件时，monorepo是一种组织和管理代码的方法。它允许将这些组件统一放在一个版本控制库中，从而简化了协作和共享代码的过程。

具体来说，monorepo是一个单一的代码库，其中包含多个项目或包。每个项目或包都可以有自己的目录结构、配置和依赖项，但它们共享相同的版本控制和构建/部署流程。这意味着如果你需要修改一个组件，你可以很容易地找到它，并且可以在同一个提交中修改多个组件。

除了共享代码繁琐，每个工具库还需要配置自己的基础设施、CI/CD 流程、开发环境，同时每个项目都需要专人来维护，这样就很容易导致项目之间的不一致性，而后提升多项目维护成本。

试想一下，如果你需要开发多个项目，而每个项目的开发模式都是不一致的，这种体验是非常糟糕的，也是非常耗费人力成本的。

但是当我们使用 monorepo 时，我们就可以在使用一套基础建设、开发规范等来降低项目维护的成本。且只需要抽出单独的 1-2 个人力去专门维护基础建设，其他项目完全不需要再关心。


####  解决问题
- 解决代码复用问题
- 开发流程统一
- 高效管理多项目/包， 节省代码体积
Monorepo的优点包括：

-   代码共享：多个项目或包可以共享代码，从而减少了代码的重复编写，提高了代码质量和一致性。
-   更好的可维护性：所有代码都在同一个版本控制库中，便于代码重构、迁移和维护。
-   更好的协作：多个开发人员可以轻松地在同一个项目中合作开发，共享代码和知识。
-   更快的构建和测试：可以在一个代码库中统一管理和构建所有组件，从而提高了构建和测试的效率。

当然，monorepo并不适用于所有情况。如果你的项目非常大或者包含非常不相关的组件，那么分离成多个库可能更好。

#### 缺点：
编译/ 依赖安装时间变长  ->  按需编译/ 手动指定编译项目
Git记录混乱 -> 所有人的commit都在一个线性历史， 需要团队的规范化处理，做好git commit检验
项目隐私性 -> 如果需要对某些仓库进行权限管理就需要慎用了， 实现不了对某个项目施加细粒度的权限控制
对IDE负担加重， 加载几十个项目的代码需要一点时间和一点点内存

### example


> 使用`pnpm`管理的一个`monorepo`例子

```json
your-monorepo/  
├── package-a/  
│   ├── package.json  
│   ├── node_modules/  
│   ├── package-a/  
│   │   ├── index.js  
│   │   ├── main.js  
│   │   ├── package-a.js  
│   │   ├── package-a-global.js  
│   ├── package-b/  
│   │   ├── package.json  
│   │   ├── node_modules/  
│   │   ├── package-b/  
│   │   │   ├── index.js  
│   │   │   ├── main.js  
│   │   │   ├── package-b.js  
│   │   │   ├── package-b-global.js  
├── package-c/  
│   ├── package.json  
│   ├── node_modules/  
│   ├── package-c/  
│   │   ├── index.js  
│   │   ├── main.js  
│   │   ├── package-c.js  
│   │   ├── package-c-global.js  
├── package-d/  

```

这个示例 monorepo 包含多个包，每个包都有自己的 `package.json` 文件和自己的 node_modules 目录。此外，每个包还拥有一些共同的依赖项，这些依赖项存储在共同的 node_modules 目录中。

使用 pnpm，开发人员可以在单个命令中安装整个 monorepo，并自动安装所有依赖项。此外，由于 pnpm 使用缓存，因此安装过程非常快，并且可以节省磁盘空间

### 未整理
生成不同的 node_modules 目录结构可能有多种原因，以下是一些可能导致不同目录结构的情况：

不同版本的依赖包：当依赖包的版本发生变化时，它们的依赖关系和下载地址可能也会发生变化，从而导致生成的 node_modules 目录结构不同。例如，如果在不同的时间或机器上安装同一个项目，但是其中的某些依赖包已经发布了新的版本，那么它们的依赖关系和下载地址可能会有所不同，从而导致生成的 node_modules 目录结构不同。

不同的操作系统：由于不同的操作系统具有不同的文件系统，因此在不同的操作系统上生成的 node_modules 目录结构可能会略有不同。例如，在 Windows 和 Mac OS 上安装同一项目时，由于文件系统和路径的差异，可能会生成略微不同的目录结构。

依赖包的版本冲突：当多个依赖包需要使用不同版本的同一依赖包时，可能会导致版本冲突，从而导致生成不同的 node_modules 目录结构。例如，如果项目需要使用 A 和 B 两个依赖包，其中 A 依赖于 C 的 1.0 版本，而 B 依赖于 C 的 2.0 版本，那么就会出现版本冲突，从而导致生成不同的 node_modules 目录结构。

这些都是可能导致生成不同的 node_modules 目录结构的原因。而使用 lock 文件可以记录下确切的版本和依赖关系，从而保证在不同的环境中生成相同的 node_modules 目录结构，避免了可能因不同环境导致的不一致性问题。


### 软连接和硬链接

硬链接是直接链接到原始文件的，可以通过多个文件名访问同一个文件，而软链接则是一个指向原始文件或目录的路径名称，因此，软链接可以链接到文件或目录。此外，当原始文件被删除时，硬链接仍然可以访问该文件，但是软链接将失效。

软链接和硬链接是Linux/Unix文件系统中使用的两种链接类型，它们都是在文件系统中创建的指向其他文件或目录的链接。

硬链接（Hard link）是一个指向文件存储位置的直接链接，它可以通过多个文件名访问同一个文件。硬链接与原始文件之间的关系是相等的，也就是说，硬链接和原始文件共享相同的i-node节点和文件内容，因此，修改硬链接或原始文件中的任何一个都会反映在所有链接上。

软链接（Symbolic link），也被称为符号链接或软连接，它是一个指向文件或目录的符号链接，与硬链接不同，软链接不会共享相同的i-node节点和文件内容。软链接是一个单独的文件，它包含指向原始文件或目录的路径名称。因此，当你打开一个软链接时，实际上是打开链接所指向的文件或目录，而不是链接本身。

总结一下，硬链接是直接链接到原始文件的，可以通过多个文件名访问同一个文件，而软链接则是一个指向原始文件或目录的路径名称，因此，软链接可以链接到文件或目录。此外，当原始文件被删除时，硬链接仍然可以访问该文件，但是软链接将失效。





### 参考链接
1. https://juejin.cn/post/7184392660939964474?share_token=53ea67e2-d1c6-45e4-ad90-ec26b139e8ca
2. https://juejin.cn/post/6932046455733485575
3. https://juejin.cn/post/7099090192887185439?share_token=1e47d0b5-9dc0-45e6-95ab-3d475212d132
4. https://zhuanlan.zhihu.com/p/77577415